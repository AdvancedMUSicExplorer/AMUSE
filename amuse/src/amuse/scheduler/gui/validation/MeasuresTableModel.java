/**
 * This file is part of AMUSE framework (Advanced MUsic Explorer).
 *
 * Copyright 2006-2010 by code authors
 *
 * Created at TU Dortmund, Chair of Algorithm Engineering
 * (Contact: <http://ls11-www.cs.tu-dortmund.de>)
 *
 * AMUSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AMUSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with AMUSE. If not, see <http://www.gnu.org/licenses/>.
 *
 * Creation date: 26.08.2008
 */
package amuse.scheduler.gui.validation;

import amuse.data.Measure;
import amuse.data.MeasureTable;
import amuse.preferences.AmusePreferences;
import amuse.preferences.KeysStringValue;
import java.io.File;
import java.io.IOException;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author Clemens WÃ¤ltken
 */
public class MeasuresTableModel extends DefaultTableModel {

    /**	Autogenerated ID for serialization */
	private static final long serialVersionUID = -8033100965831419053L;
    private File measureTableFile = new File(AmusePreferences.getMeasureTablePath());
    private MeasureTable measureTable;

    public MeasuresTableModel() throws IOException {
        super();
        measureTable = new MeasureTable(measureTableFile);
        Object[][] data = new Object[measureTable.size()][5];
        String[] columnHeaders = {"ID", "Name", "Category", "Track Level", "Window Level"};
        int index = 0;
        for (Object[] column:data) {
            amuse.data.Measure m = measureTable.get(index);
            column[0] = m.getID();
            column[1] = m.getName();
            column[2] = m.getCategory();
            column[3] = m.isTrackLevelSelected();
            column[4] = m.isWindowLevelSelected();
            index++;
        }
        this.setDataVector(data, columnHeaders);
    }

    public void loadSelection(MeasureTable table) {
        for (int i = 0; i < table.size(); i++) {
           setValueAt(table.get(i).isTrackLevelSelected(), i, 3);
           setValueAt(table.get(i).isWindowLevelSelected(), i, 4);
        }
    }
  
    @Override
    public boolean isCellEditable (int row, int col) {
        if (col >= 3) {
            return true;
        } else {
            return false;
        }
    }

    @Override
    public Class<?> getColumnClass(int index) {
        if (index == 0) {
            return Integer.class;
        } else if (index == 1 || index == 2) {
            return String.class;
        } else if (index == 3 || index == 4) {
            return Boolean.class;
        } else {
            throw new IndexOutOfBoundsException("No column at: " + index);
        }
    }

    private void setDataVector(Object[][] data, String[] columnHeaders) {
        super.setDataVector(data, columnHeaders);
    }

    public MeasureTable getMeasureTable() {
        for (int i = 0; i < getRowCount(); i++) {
            boolean trackLevel = (Boolean)getValueAt(i, 3);
            boolean classificationWindowLevel = (Boolean)getValueAt(i, 4);
            Measure measure = measureTable.get(i);
            measure.setTrackLevelSelected(trackLevel);
            measure.setWindowLevelSelected(classificationWindowLevel);
        }
        return measureTable;
    }
}
